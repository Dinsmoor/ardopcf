// This file was created from 'webgui.js' by txt2c.
// Rather than editing this file directly, it may better to edit
// that source file, and then use txt2c to rebuild this file.

const char webgui_js[] = (
"\"use strict\"\n"
"/////////////////////////////////////////////////////////////////////////////\n"
"//\n"
"//  The protocol used to communicate with ardopcf via a WebSocket connection\n"
"//  should be considered unstable and undocumented.  It is subject to change\n"
"//  in future releases of ardopcf.\n"
"//\n"
"/////////////////////////////////////////////////////////////////////////////\n"
"\n"
"\n"
"// Define a 4-bit (16 values) RGB modified rainbow colormap from blue to red\n"
"// to use for the waterfall display.  A few additional colormap entries are\n"
"// also included.\n"
"let alpha = 0xFF\n"
"let colormap = [\n"
"  [0x30, 0x12, 0x3b, alpha], [0x41, 0x43, 0xa7, alpha],\n"
"  [0x47, 0x71, 0xe9, alpha], [0x3e, 0x9b, 0xfe, alpha],\n"
"  [0x22, 0xc5, 0xe2, alpha], [0x1a, 0xe4, 0xb6, alpha],\n"
"  [0x46, 0xf8, 0x84, alpha], [0x88, 0xff, 0x4e, alpha],\n"
"  [0xb9, 0xf6, 0x35, alpha], [0xe1, 0xdd, 0x37, alpha],\n"
"  [0xfa, 0xba, 0x39, alpha], [0xfd, 0x8d, 0x27, alpha],\n"
"  [0xf0, 0x5b, 0x12, alpha], [0xd6, 0x35, 0x06, alpha],\n"
"  [0xaf, 0x18, 0x01, alpha], [0x7a, 0x04, 0x03, alpha],\n"
"  // special values\n"
"  [0x00, 0x00, 0x00, alpha], // 16 black\n"
"  [0xFF, 0xFF, 0xFF, alpha], // 17 white\n"
"  [0xD0, 0xD0, 0xD0, alpha], // 18 light gray (for bw lines when !isbusy)\n"
"  [0xFF, 0x00, 0xFF, alpha], // 19 fuscia (for bw lines when isbusy)\n"
"];\n"
"\n"
"let bandwidth = -1;  // in Hz.  -1 = unknown\n"
"let isbusy = 0;\n"
"let devmode = false;\n"
"let cmdhistory = [];\n"
"let cmdhistory_index = -1;\n"
"let cmdhistory_limit = 100;\n"
"let plotscale = 1;\n"
"\n"
"window.addEventListener(\"load\", function(evt) {\n"
"  let txtlog = document.getElementById(\"text-log\");\n"
"  let decoder = new TextDecoder(\"utf-8\");\n"
"  let encoder = new TextEncoder(\"utf-8\");\n"
"\n"
"  // rsize should match WG_SSIZE in Webgui.c.\n"
"  // This is the maximum length of messages received from ardopcf\n"
"  const rsize = 2048;\n"
"  // ssize should match WG_RSIZE in Webgui.c.\n"
"  // This is the maximum length of messages sent to ardopcf\n"
"  const ssize = 512;\n"
"  // max_avglen should match MAX_AVGLEN in Webgui.c.\n"
"  // This is the maximum number of FFT results to average.\n"
"  const max_avglen = 10;\n"
"  document.getElementById(\"avglenslider\").max = max_avglen;\n"
"  let rdata = {\n"
"    // Assuming a single message may have a length up to rsize, create buf\n"
"    // large enough to hold up to two complete messages.  Thus allowing\n"
"    // for a single WS frame to include the last few bytes of one message\n"
"    // as well as all of a following message.\n"
"    buf: new Uint8Array(2 * rsize),\n"
"    len: 0,  // number of bytes of data in buf\n"
"    offset: 0,  // offset of next unparsed value in buf.\n"
"    condense: function() {\n"
"      // discard the portion of buf that has been parsed.\n"
"      if (this.offset == 0)\n"
"        return;\n"
"      if (this.offset == this.len)\n"
"        this.len = 0;\n"
"      else {\n"
"        this.buf.copyWithin(0, this.offset, this.len);\n"
"        this.len -= this.offset;\n"
"      }\n"
"      this.offset = 0;\n"
"    }\n"
"  };\n"
"\n"
"  // return the number of bytes used to encode uvalue\n"
"  // Return -1 on failure\n"
"  const encodeUvint = (buf, size, uvalue) => {\n"
"    let i = 0;\n"
"    while(uvalue >= 0x80) {\n"
"      buf[i++] = (uvalue & 0x7f) + 0x80;\n"
"      if (i >= size)\n"
"        return (-1);\n"
"      uvalue >>= 7;\n"
"    }\n"
"    buf[i++] = uvalue;\n"
"    return (i);\n"
"  };\n"
"\n"
"  // Decode a variable length unsigned integer (uvint)\n"
"  // Return the decoded value and update rdata.offset.\n"
"  // But, if unable to decode a uvint from rdata because it does not contain\n"
"  // sufficient data, then return -1 and make no changes to rdata.\n"
"  const decodeUvint = (rdata) => {\n"
"    let result = 0;\n"
"    let shift = 0;\n"
"    let original_offset = rdata.offset;\n"
"    while (true) {\n"
"      if (rdata.offset >= rdata.len) {\n"
"        // unable to decode uvint\n"
"        rdata.offset = original_offset;\n"
"        return -1;\n"
"      }\n"
"      const byte = rdata.buf[rdata.offset];\n"
"      rdata.offset += 1;\n"
"      result |= (byte & 0x7f) << shift;\n"
"      //console.log(\"With byte=\" + byte + \" result becomes \" + result);\n"
"      shift += 7;\n"
"      if ((0x80 & byte) === 0) {\n"
"        return result;\n"
"      }\n"
"    }\n"
"  };\n"
"\n"
"  // Decode a single byte (unsigned char)\n"
"  // Return the decoded value and update rdata.offset.\n"
"  // But, if no data is available (rdata.offset == rdata.len),\n"
"  // then return -1 and make no changes to rdata.\n"
"  // (To get a single byte as a string, use decodestr(rdata, 1))\n"
"  const decodebyte = (rdata) => {\n"
"    if (rdata.offset >= rdata.len)\n"
"      // unable to decode value\n"
"      return -1;\n"
"    rdata.offset += 1;\n"
"    return rdata.buf[rdata.offset - 1];\n"
"  }\n"
"\n"
"  // Decode a string\n"
"  // Return the decoded string and update rdata.offset.\n"
"  // If strlen is -1, then return the remainder of the message.\n"
"  // But, if strlen is not -1, and insufficient data is available,\n"
"  // then return an empty string and make no changes to rdata.\n"
"  const decodestr = (rdata, strlen) => {\n"
"    if (strlen >= 0 && rdata.offset + strlen > rdata.len)\n"
"      // unable to decode value\n"
"      return \"\";\n"
"    if (strlen == -1)\n"
"      strlen = rdata.len - rdata.offset;\n"
"    rdata.offset += strlen;\n"
"    return decoder.decode(\n"
"      rdata.buf.slice(rdata.offset - strlen, rdata.offset));\n"
"  }\n"
"\n"
"  // Return a slice of rdata and update rdata.offset.\n"
"  // If sllen is -1, then return the remainder of the message.\n"
"  // But, if sllen is not -1, and insufficient data is available,\n"
"  // then return null and make no changes to rdata.\n"
"  const decodeslice = (rdata, sllen) => {\n"
"    if (sllen >= 0 && rdata.offset + sllen > rdata.len)\n"
"      return null;\n"
"    if (sllen == -1)\n"
"      sllen = rdata.len - rdata.offset;\n"
"    rdata.offset += sllen;\n"
"    return rdata.buf.slice(rdata.offset - sllen, rdata.offset);\n"
"  }\n"
"\n"
"  var WebSocketClient = (function () {\n"
"    var exports = {};\n"
"    var is_connected = false;\n"
"    var is_closing = false;\n"
"    var ws = null;\n"
"\n"
"    exports.init = function(url) {\n"
"      if (!WebSocket in window){\n"
"        throw \"WebSocket NOT supported by your Browser!\"\n"
"      }\n"
"\n"
"      if (is_connected) {\n"
"        console.log(\"WS connection already open.  Do nothing.\");\n"
"      } else {\n"
"        console.log(\"Open WS connection to \", url);\n"
"        ws = new WebSocket(url);\n"
"      }\n"
"      ws.binaryType = \"arraybuffer\"; // otherwise defaults to blob\n"
"      ws.onopen = function() {\n"
"        is_connected = true;\n"
"        if(exports.onOpen){\n"
"          exports.onOpen();\n"
"        }\n"
"      };\n"
"\n"
"      ws.onmessage = function (evt) {\n"
"        var msg = evt.data;\n"
"\n"
"        if(exports.onMessage) {\n"
"          exports.onMessage(msg);\n"
"        }\n"
"      };\n"
"\n"
"      ws.onerror = function (err) {\n"
"        is_connected = false;\n"
"        console.log(err);\n"
"        document.getElementById(\"lostcon\").classList.remove(\"dnone\");\n"
"      };\n"
"\n"
"      ws.onclose = function() {\n"
"        if (is_closing) {\n"
"          console.log(\"Response to close received from WS server.\");\n"
"          is_closing = false;\n"
"          is_connected = false;\n"
"        } else if (is_connected) {\n"
"          console.log(\"WS server is closing connection.\");\n"
"          // Respond with confirmation of close.\n"
"          ws.close();\n"
"          is_connected = false;\n"
"        } else {\n"
"          // already closed\n"
"          console.log(\"Received unexpected close from WS server.\");\n"
"        }\n"
"        document.getElementById(\"lostcon\").classList.remove(\"dnone\");\n"
"      };\n"
"\n"
"    }\n"
"\n"
"    exports.sendMessage = function (msg) {\n"
"      if (is_connected) {\n"
"        ws.send(msg);\n"
"      } else {\n"
"        alert(\"Not connected!\");\n"
"      }\n"
"    };\n"
"\n"
"    exports.close = function () {\n"
"      if (is_closing) {\n"
"        console.log(\"Close already sent to server.  No response yet.\");\n"
"        document.getElementById(\"lostcon\").classList.remove(\"dnone\");\n"
"      } else if (is_connected) {\n"
"        console.log(\"Sending close to WS server.\");\n"
"        ws.close();\n"
"        is_closing = true;\n"
"      } else {\n"
"        console.log(\"No open WS connection to close.\");\n"
"      }\n"
"    };\n"
"\n"
"    exports.onMessage = null;\n"
"    exports.onOpen = null;\n"
"    return exports;\n"
"  }());\n"
"  // buffer is an ArrayBuffer.  Returns string\n"
"  const buf2hex = (buffer) =>\n"
"    [...new Uint8Array(buffer)].map(\n"
"      x => x.toString(16).padStart(2, '0')\n"
"    ).join('');\n"
"\n"
"  // hexString is string.  Returns an Array of uint8 values\n"
"  // Optional whitespace is removed before conversion.\n"
"  // Terminate at end of hexString or upon encountering a\n"
"  // character that is neither whitespace nor valid hex.\n"
"  const fromHexString = (hexString) =>\n"
"    hexString.replace(/\\s+/g, \"\").match(/.{1,2}/g).map((byte) =>\n"
"    parseInt(byte, 16));\n"
"\n"
"  // Process messages from Webgui clients\n"
"  // Two protocol layers are defined for messages from Webgui clients.\n"
"  // The lower level protocol prefaces each message with a variable\n"
"  // length unsigned integer (uvint) which specifies the length of the\n"
"  // message excluding the length of this header.\n"
"  // The higher level protocol specifies that the first byte of each\n"
"  // message indicates the message type, and this shall always be\n"
"  // followed by a tilde '~' 0x7E.  This printable and easily typed\n"
"  // character that is not widely used provides an imperfect but\n"
"  // reasonably reliable way to detect a message handling error that\n"
"  // has caused the start of a message to be incorrectly located.\n"
"  // Each message type specifies the required format for the remainder\n"
"  // of the message, if any.  Where a message includes a string, no\n"
"  // terminating NULL will be included at the end of the string.  The\n"
"  // length of the message provided by the lower level protocol shall\n"
"  // be used to determine the length of a string or other variable\n"
"  // length data at the end of a message.\n"
"  //\n"
"  // To simplify the printing of raw messages for debugging purposes,\n"
"  // message type bytes that represent printable ASCII characters in\n"
"  // the range of 0x20 (space) to 0x7D (closing brace) shall be used\n"
"  // for messages whose entire raw content may be printed as human\n"
"  // readable text (though they will not include a NULL terminator),\n"
"  // while the remaining type bytes indicate that for logging\n"
"  // purposes, the message should be displayed as a sequence of\n"
"  // hexidecimal values.\n"
"  // \"0~\" no additional data: Client connected/reconnected\n"
"  // \"2~\" no additional data: Request ardopcf to send 5 send two tone signal.\n"
"  // \"I~\" no additional data: Request ardopcf to send ID frame.\n"
"  // 0x8D7E followed by one additional byte interpreted as an unsigned\n"
"  //   char in the range 0 to 100: Set DriveLevel\n"
"  // 0x9A7E followed by one additional byte interpreted as an unsigned\n"
"  //   char in the range 1 to max_avglen: Set display averaging length\n"
"\n"
"  // Send data of length data_len to the server.\n"
"  // This function implements the lower level protocol of adding a\n"
"  // uvint header to the start of each message indicating the\n"
"  // length of its body (excluding the header length).\n"
"  const send_msg = (data, data_len) => {\n"
"    if (String.fromCharCode(data[1]) != \"~\") {\n"
"      alert(\"ERROR: Invalid message.  second byte is not '~'.\");\n"
"      return (0);\n"
"    }\n"
"    let smsg = new Uint8Array(ssize);\n"
"    let headlen;\n"
"    if ((headlen = encodeUvint(smsg, ssize, data_len)) == -1)\n"
"      return (0);\n"
"    if (data_len + headlen > ssize) {\n"
"      alert(\"ERROR: data to send to ardopcf is too big.  Discarding.\");\n"
"      return (0);\n"
"    }\n"
"    smsg.set(new Uint8Array(data.slice(0, data_len)), headlen);\n"
"    WebSocketClient.sendMessage(smsg.slice(0, data_len + headlen));\n"
"  }\n"
"\n"
"  const send_connected = () => {\n"
"    // Notify ardopcf that this Webgui client has connected.\n"
"    send_msg(encoder.encode(\"0~\"), 2);\n"
"  }\n"
"\n"
"  const send_send2tone = () => {\n"
"    // Tell ardopcf to send an two tone test signal.\n"
"    send_msg(encoder.encode(\"2~\"), 2);\n"
"  }\n"
"\n"
"  const send_sendid = () => {\n"
"    // Tell ardopcf to send an ID frame.\n"
"    send_msg(encoder.encode(\"I~\"), 2);\n"
"  }\n"
"\n"
"  // Use throttles to limit the number of updates sent to ardopcf in\n"
"  // response to the user adjusting the AvgLen or DriveLevel sliders.\n"
"  let avglencontroltimer = false;\n"
"  let drivelevelcontroltimer = false;\n"
"  const throttledcontrol = (callback, time, controltimer) => {\n"
"    if (controltimer) return;\n"
"    controltimer = true;\n"
"    setTimeout(() => {\n"
"      callback();\n"
"      controltimer = false;\n"
"    }, time);\n"
"  }\n"
"  const setavglen = () => {\n"
"    document.getElementById(\"avglentext\").innerHTML = \"\"\n"
"      + document.getElementById(\"avglenslider\").value;\n"
"    let msgdata = new Uint8Array(\n"
"      [0x9A, 0x7E, document.getElementById(\"avglenslider\").value]);\n"
"    send_msg(msgdata, 3);\n"
"  }\n"
"  const setdrivelevel = () => {\n"
"    document.getElementById(\"driveleveltext\").innerHTML =\n"
"      \"\" + document.getElementById(\"drivelevelslider\").value;\n"
"    let msgdata = new Uint8Array(\n"
"      [0x8D, 0x7E, document.getElementById(\"drivelevelslider\").value]);\n"
"    send_msg(msgdata, 3);\n"
"  }\n"
"\n"
"  let clearrxtimer = null;\n"
"  let rcvoverflowtimer = null;\n"
"  let rcvunderflowtimer = null;\n"
"  WebSocketClient.onOpen = function() {\n"
"    // Connection to ardopcf established.\n"
"    console.log(\"WS connection to ardopcf opened.  Notify ardopcf.\");\n"
"    send_connected();\n"
"  }\n"
"  WebSocketClient.onMessage = function(wsdata) {\n"
"    // Two protocol layers are defined for messages to Webgui clients.\n"
"    // The lower level protocol prefaces each message with a variable\n"
"    // length unsigned integer (uvint) which specifies the length of the\n"
"    // message excluding the length of this header.\n"
"    // The higher level protocol specifies that the first byte of each\n"
"    // message indicates the message type, and this shall always be\n"
"    // followed by a pipe '|' 0x7C.  This printable and easily typed\n"
"    // character that is not widely used provides an imperfect but\n"
"    // reasonably reliable way to detect a message handling error that\n"
"    // has caused the start of a message to be incorrectly located.\n"
"    // Each message type specifies the required format for the remainder\n"
"    // of the message, if any.  Where a message includes a string, no\n"
"    // terminating NULL will be included at the end of the string.  The\n"
"    // length of the message provided by the lower level protocol shall\n"
"    // be used to determine the length of a string or other variable\n"
"    // length data at the end of a message.\n"
"    //\n"
"    // To simplify the printing of raw messages for debugging purposes,\n"
"    // message type bytes that represent printable ASCII characters in\n"
"    // the range of 0x20 (space) to 0x7D (closing brace) shall be used\n"
"    // for messages whose entire raw content may be printed as human\n"
"    // readable text (though they will not include a NULL terminator),\n"
"    // while the remaining type bytes indicate that for logging\n"
"    // purposes, the message should be displayed as a sequence of\n"
"    // hexidecimal values.\n"
"    // \"a|\" followed by string: Alert for user.\n"
"    // \"B|\" no additional data: BUSY true\n"
"    // \"b|\" no additional data: BUSY false\n"
"    // \"C|\" followed by a string: My callsign\n"
"    //   If string has zero length, clear my callsign.\n"
"    // \"c|\" followed by a string: remote callsign\n"
"    //   If string has zero length, clear remote callsign.\n"
"    // \"D|\" no additional data: Enable Dev Mode\n"
"    // \"F|\" followed by a string: TX Frame type\n"
"    // \"f|\"\n"
"    //   followed by a character:\n"
"    //    'P' for pending, 'O' for OK, or 'F' for fail\n"
"    //   followed by a string: RX Frame state and type\n"
"    // \"H|\"\n"
"    //   followed by a character:\n"
"    //    'Q' for QueueCommandToHost\n"
"    //    'C' for SendCommandToHost\n"
"    //    'T' for SendCommandToHostQuiet\n"
"    //    'R' for SendReplyToHost\n"
"    //    'F' for Command from Host.\n"
"    //   followed by a string: Message to host\n"
"    // \"h|\" followed by a string: Host text data (to host)\n"
"    // \"m|\" followed by a string: Protocol Mode\n"
"    // \"P|\" no additional data: PTT true\n"
"    // \"p|\" no additional data: PTT false\n"
"    // \"R|\" no additional data: IRS true\n"
"    // \"r|\" no additional data: IRS false\n"
"    // \"S|\" no additional data: ISS true\n"
"    // \"s|\" no additional data: ISS false\n"
"    // \"t|\" followed by a string: Protocol State\n"
"    // 0x817C followed by one additional byte interpreted as an unsigned\n"
"    //   char in the range of 0 to 150: Set CurrentLevel\n"
"    // 0x8A7C\n"
"    //   followed by an unsigned char: Quality (0-100)\n"
"    //   followed by a uvint: The total number of errors detected by RS\n"
"    //   followed by a uvint: The max number of errors correctable by RS\n"
"    //   (For a failed decode, total will be set equal to max + 1)\n"
"    // 0x8B7C followed by one unsigned char: Bandwidth in Hz divided by 10.\n"
"    // 0x8C7C followed by 103 bytes of data: FFT power (dBfs 4 bits each).\n"
"    // 0x8D7C followed by one additional byte interpreted as an unsigned\n"
"    //   char in the range 0 to 100: Set DriveLevel\n"
"    // 0x8E7C followed by unsigned char data: Pixel data (x, y, color)\n"
"    //   color is 1, 2, or 3 for poor, ok, good.\n"
"    // 0x8F7C followed by unsigned char data: Host non-text data (to host)\n"
"    //   The first three characters of data are text data indicating\n"
"    //   data type 'FEC', 'ARQ', 'RXO', 'ERR', etc.\n"
"    // 0x9A7C followed by one additional byte interpreted as an unsigned\n"
"    //   char in the range 1 to MAX_AVGLEN: Set display averaging length\n"
"\n"
"    if(!(wsdata instanceof ArrayBuffer)) {\n"
"      alert(\"Unexpected WS data format.  Closing connection.\");\n"
"      WebSocketClient.close();\n"
"      return;\n"
"    }\n"
"    if (wsdata.byteLength + rdata.len > 2 * rsize) {\n"
"      alert(\"ERROR.  rdata.buf overrun.  Closing connection.\");\n"
"      WebSocketClient.close();\n"
"      return;\n"
"    }\n"
"    rdata.buf.set(new Uint8Array(wsdata), rdata.len);\n"
"    rdata.len += wsdata.byteLength;\n"
"    let msglen;\n"
"    let startoffset = rdata.offset; // offset of msglen\n"
"    while((msglen = decodeUvint(rdata)) >= 0) {\n"
"      let msgoffset = rdata.offset; // offset after msglen\n"
"      if (msglen == 0) {\n"
"        // An empty message.  Do nothing.\n"
"        // update startoffset before parsing next msglen\n"
"        startoffset = rdata.offset;\n"
"        continue;\n"
"      }\n"
"      if ((rdata.len - rdata.offset) < msglen) {\n"
"        // The complete message has not yet been received.\n"
"        // rewind parsing of msglen\n"
"        rdata.offset = startoffset;\n"
"        break;\n"
"      }\n"
"      // For readability, use equivalent string value for msgtype\n"
"      // Using decodestr(rdata, 1) wouldn't work for non-text types.\n"
"      let msgtype = String.fromCharCode(decodebyte(rdata));\n"
"      if (msgtype == \"\\uffff\") {\n"
"        console.log(\"Message type not available.  Message too short.\",\n"
"          rdata.buf.slice(startoffset, msgoffset + msglen));\n"
"        alert(\"Message type not available.  Closing connection.\");\n"
"        WebSocketClient.close();\n"
"        return;\n"
"      }\n"
"      let pipe = decodestr(rdata, 1);\n"
"      console.log(\"pipe\", pipe);\n"
"      if (pipe != \"|\") {\n"
"        console.log(\"Expected '|' after message type byte not found.\",\n"
"          rdata.buf.slice(startoffset, msgoffset + msglen));\n"
"        alert(\"Invalid message structure.  Closing connection.\");\n"
"        WebSocketClient.close();\n"
"        return;\n"
"      }\n"
"      switch (msgtype) {\n"
"        case \"a\": {\n"
"          // Alert message (display)\n"
"          let str = decodestr(rdata, -1);\n"
"          if (str == \"\")\n"
"            str = \"ERROR: Invalid 'Alert' message received.\"\n"
"          alert(str);\n"
"          break;\n"
"        }\n"
"        case \"B\":\n"
"          // BUSY true\n"
"          isbusy = 1;\n"
"          // txtlog.value += \"BUSY = true\\n\";\n"
"          // txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"busy\").classList.remove(\"hidden\");\n"
"          break;\n"
"        case \"b\":\n"
"          // BUSY false\n"
"          isbusy = 0;\n"
"          // txtlog.value += \"BUSY = false\\n\";\n"
"          // txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"busy\").classList.add(\"hidden\");\n"
"          break;\n"
"        case \"C\": {\n"
"          // My callsign\n"
"          let mycall = decodestr(rdata, -1);\n"
"          if (mycall == \"\") {\n"
"            // clear mycall\n"
"            txtlog.value += \"Clear my callsign\\n\";\n"
"            document.getElementById(\"mycall\").innerHTML =\n"
"              \"(MYCALL NOT SET)\";\n"
"          } else {\n"
"            txtlog.value += \"My callsign = \" + mycall + \"\\n\";\n"
"            document.getElementById(\"mycall\").innerHTML = mycall;\n"
"          }\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          break;\n"
"        }\n"
"        case \"c\": {\n"
"          // Remote callsign\n"
"          let rcall = decodestr(rdata, -1);\n"
"          if (rcall == \"\") {\n"
"            // clear rcall\n"
"            txtlog.value += \"[\" + (new Date().toISOString()) + \"]\"\n"
"              + \"  Clear remote callsign.  Was \"\n"
"              + document.getElementById(\"rcall\").innerHTML\n"
"              + \"\\n\";\n"
"            document.getElementById(\"rcall\").innerHTML = \"\";\n"
"          } else {\n"
"            txtlog.value += \"[\" + (new Date().toISOString()) + \"]\"\n"
"              + \"  Remote callsign = \" + rcall + \"\\n\";\n"
"            document.getElementById(\"rcall\").innerHTML = rcall;\n"
"          }\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          break;\n"
"        }\n"
"        case \"D\":\n"
"          // Enable Dev Mode\n"
"          devmode = true;\n"
"          document.getElementById(\"devmode\")\n"
"            .classList.remove(\"dnone\");\n"
"          txtlog.value += \"DevMode Enabled\\n\";\n"
"          break;\n"
"        case \"F\": {\n"
"          // TX Frame type\n"
"          let txfrtype = decodestr(rdata, -1);\n"
"          let txe = document.getElementById(\"txtype\");\n"
"          if (txfrtype != \"\") {\n"
"            txtlog.value += \"TX Frame Type = \" + txfrtype + \"\\n\";\n"
"            txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          }\n"
"          txe.innerHTML = txfrtype;\n"
"          if (txfrtype == \"DataNAK\")\n"
"            txe.classList.add(\"txnak\");\n"
"          if (txfrtype == \"DataACK\")\n"
"            txe.classList.add(\"txack\");\n"
"          break;\n"
"        }\n"
"        case \"f\": {\n"
"          // RX Frame type\n"
"          let rxstatus = decodestr(rdata, 1);\n"
"          let rxfrtype = decodestr(rdata, -1);\n"
"          let rxe = document.getElementById(\"rxtype\");\n"
"          rxe.classList.remove(\"rxstate_pending\");\n"
"          rxe.classList.remove(\"rxstate_ok\");\n"
"          rxe.classList.remove(\"rxstate_fail\");\n"
"          rxe.classList.remove(\"rxstate_none\");\n"
"          clearTimeout(clearrxtimer);  // eliminate old timer\n"
"          if (rxstatus == \"\"\n"
"            || \"POF\".indexOf(rxstatus) == -1\n"
"          ) {\n"
"            alert(\"Invalid state for RX Frame Type.\");\n"
"            rxe.classList.add(\"rxstate_none\");\n"
"          }\n"
"          switch (rxstatus) {\n"
"            case \"P\":\n"
"            rxe.classList.add(\"rxstate_pending\");\n"
"            // Assume that this will always be folowed\n"
"            // by a rxstate_ok or rxstate_fail, so don't\n"
"            // set a timer to clear it.\n"
"            // Don't write pending rx to txtlog\n"
"            break;\n"
"            case \"O\":\n"
"            rxe.classList.add(\"rxstate_ok\");\n"
"            clearrxtimer = setTimeout(() => {\n"
"              rxe.innerHTML = \"\";\n"
"              rxe.classList.remove(\"rxstate_ok\");\n"
"              rxe.classList.add(\"rxstate_none\");\n"
"            }, 5000);  /// clear after 5 seconds\n"
"            txtlog.value += \"RX: \" + rxfrtype + \" PASS\\n\";\n"
"            txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"            break;\n"
"            case \"F\":\n"
"            rxe.classList.add(\"rxstate_fail\");\n"
"            clearrxtimer = setTimeout(() => {\n"
"              rxe.innerHTML = \"\";\n"
"              rxe.classList.remove(\"rxstate_fail\");\n"
"              rxe.classList.add(\"rxstate_none\");\n"
"            }, 5000);  /// clear after 5 seconds\n"
"            txtlog.value += \"RX: \" + rxfrtype + \" FAIL\\n\";\n"
"            txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"            break;\n"
"          }\n"
"          rxe.innerHTML = rxfrtype;\n"
"          break;\n"
"        }\n"
"        case \"H\": {\n"
"          // Host message\n"
"          if (!devmode)\n"
"            console.log(\n"
"              \"WARNING: receiving Host messages when not in\"\n"
"              + \" devmode\");\n"
"          let hostmsgtype = decodestr(rdata, 1);\n"
"          let hostmsg = decodestr(rdata, -1);\n"
"          let prefix = \"\"\n"
"          switch (hostmsgtype) {\n"
"            case 'Q':\n"
"              prefix = \"QueueCommandToHost(): \";\n"
"              break;\n"
"            case 'C':\n"
"              prefix = \"SendCommandToHost(): \";\n"
"              break;\n"
"            case 'T':\n"
"              prefix = \"SendCommandToHostQuiet(): \";\n"
"              break;\n"
"            case 'R':\n"
"              prefix = \"SendReplyToHost(): \";\n"
"              break;\n"
"            case 'F':\n"
"              prefix = \"CommandFromHost(): \";\n"
"              break;\n"
"          }\n"
"          txtlog.value += prefix + hostmsg + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          break;\n"
"        }\n"
"        case \"h\":\n"
"          // Host text data\n"
"          if (!devmode)\n"
"            console.log(\n"
"              \"WARNING: receiving text data Host messages when\"\n"
"              + \" not in devmode\");\n"
"          txtlog.value += \"Data (text) to Host: (\"\n"
"            + decodestr(rdata, 3) + \") \" + decodestr(rdata, -1) + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          break;\n"
"        case \"m\": {\n"
"          // Protocol Mode\n"
"          let mode = decodestr(rdata, -1);\n"
"          txtlog.value += \"Protocol Mode = \" + mode + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"protocolmode\").innerHTML = mode;\n"
"          break;\n"
"        }\n"
"        case \"P\":\n"
"          // PTT true\n"
"          // txtlog.value += \"PTT = true\\n\";\n"
"          // txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"ptt\").classList.remove(\"hidden\");\n"
"          break;\n"
"        case \"p\": {\n"
"          // PTT false\n"
"          // txtlog.value += \"PTT = false\\n\";\n"
"          // txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"ptt\").classList.add(\"hidden\");\n"
"          // Clear txtype when done transmitting\n"
"          let txe = document.getElementById(\"txtype\");\n"
"          txe.innerHTML = \"\";\n"
"          txe.classList.remove(\"txnak\");\n"
"          txe.classList.remove(\"txack\");\n"
"          break;\n"
"        }\n"
"        case \"R\":\n"
"          // IRS true\n"
"          txtlog.value += \"IRS = true\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"irs\").classList.remove(\"dnone\");\n"
"          break;\n"
"        case \"r\":\n"
"          // IRS false\n"
"          txtlog.value += \"IRS = false\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"irs\").classList.add(\"dnone\");\n"
"          break;\n"
"        case \"S\":\n"
"          // ISS true\n"
"          txtlog.value += \"ISS = true\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"iss\").classList.remove(\"dnone\");\n"
"          break;\n"
"        case \"s\":\n"
"          // ISS false\n"
"          txtlog.value += \"ISS = false\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"iss\").classList.add(\"dnone\");\n"
"          break;\n"
"        case \"t\": {\n"
"          let state = decodestr(rdata, -1);\n"
"          if (state == \"DISC\")\n"
"            txtlog.value += \"[\" + (new Date().toISOString()) + \"]\"\n"
"              + \"  State = \" + state + \"\\n\";\n"
"          else\n"
"            txtlog.value += \"State = \" + state + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"state\").innerHTML = state;\n"
"          break;\n"
"        }\n"
"        case \"\\x81\": {\n"
"          // CurrentLevel update\n"
"          // linear fraction of recieved fullscale audio scale\n"
"          // rescaled to 0-150\n"
"          let rlevel = decodebyte(rdata);\n"
"          document.getElementById(\"rcvlvl\").value = rlevel;\n"
"          if (rlevel >= 148) {\n"
"            clearTimeout(rcvoverflowtimer);  // eliminate old timer\n"
"            let rcvoe = document.getElementById(\"rcvoverflow\");\n"
"            rcvoe.classList.remove(\"dnone\");\n"
"            rcvoverflowtimer = setTimeout(() => {\n"
"              rcvoe.classList.add(\"dnone\");\n"
"            }, 5000);  /// display for 5 seconds\n"
"          }\n"
"          if (rlevel <= 2) {\n"
"            clearTimeout(rcvunderflowtimer); // eliminate old timer\n"
"            let rcvue = document.getElementById(\"rcvunderflow\");\n"
"            rcvue.classList.remove(\"dnone\");\n"
"            rcvunderflowtimer = setTimeout(() => {\n"
"              rcvue.classList.add(\"dnone\");\n"
"            }, 1000);  /// display for 1 second\n"
"          }\n"
"          break;\n"
"        }\n"
"        case \"\\x8A\": {\n"
"          // Quality\n"
"          let quality = decodebyte(rdata);\n"
"          let rserrors = decodeUvint(rdata);\n"
"          let rsmax = decodeUvint(rdata);\n"
"          if (rsmax < 0) {\n"
"            alert(\"ERROR: Invalid quality data.\");\n"
"            break;\n"
"          }\n"
"          txtlog.value += \"Quality = \" + quality + \"/100\\n\";\n"
"          txtlog.value += \"RS Errors = \" + rserrors\n"
"            + \"/\" + rsmax + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"quality\").innerHTML =\n"
"            \"Quality: \" + quality + \"/100\";\n"
"          document.getElementById(\"rserrs\").innerHTML =\n"
"            \"RS Errors: \" + rserrors + \"/\" + rsmax;\n"
"          break;\n"
"        }\n"
"        case \"\\x8B\": {\n"
"          // Bandwidth update\n"
"          let bw = decodebyte(rdata);\n"
"          if (bw == -1) {\n"
"            alert(\"Error: Invalid bandwidth.\");\n"
"            break;\n"
"          }\n"
"          bandwidth = 10 * bw;\n"
"          txtlog.value += \"Bandwidth = \" + bw + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          break;\n"
"        }\n"
"        case \"\\x8C\": {\n"
"          // 4-bit spectral data for waterfall plot\n"
"          let sdata = decodeslice(rdata, -1);\n"
"          if (sdata == null) {\n"
"            alert(\"ERROR: Invalid spectral data.\");\n"
"            break;\n"
"          }\n"
"          addWaterfallLine(sdata);\n"
"          drawSpectrum(sdata);\n"
"          break;\n"
"        }\n"
"        case \"\\x8D\": {\n"
"          // DriveLevel update\n"
"          let dl = decodebyte(rdata);\n"
"          txtlog.value += \"DriveLevel = \" + dl + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"driveleveltext\").innerHTML =\n"
"            \"\" + dl;\n"
"          document.getElementById(\"drivelevelslider\").value = dl;\n"
"          break;\n"
"        }\n"
"        case \"\\x8E\": {\n"
"          // Pixel data for constellation plot (x, y, color)\n"
"          let pixeldata = decodeslice(rdata, -1);\n"
"          drawConstellation(pixeldata);\n"
"          break;\n"
"        }\n"
"        case \"\\x8F\":\n"
"          // Data non-text to Host\n"
"          if (!devmode)\n"
"            console.log(\n"
"              \"WARNING: receiving non-text data Host messages\"\n"
"              + \" when not in devmode\");\n"
"          txtlog.value += \"Data (non-text) to Host: (\"\n"
"            + decodestr(rdata, 3) + \") \"\n"
"            + buf2hex(decodeslice(rdata, -1))\n"
"            + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          break\n"
"        case \"\\x9A\": {\n"
"          // AvgLen update\n"
"          let avglen = decodebyte(rdata);\n"
"          txtlog.value += \"AvgLen = \" + avglen + \"\\n\";\n"
"          txtlog.scrollTo(0, txtlog.scrollHeight);\n"
"          document.getElementById(\"avglentext\").innerHTML =\n"
"            \"\" + avglen;\n"
"          document.getElementById(\"avglenslider\").value = avglen;\n"
"          break;\n"
"        }\n"
"        default:\n"
"          txtlog.value +=\n"
"            \"WARNING: Received an unexpected message of type=\"\n"
"            + msgtype + \" and length=\" + msglen + \"\\n\";\n"
"          if (typeof(msgtype) == \"string\")\n"
"            // This message can be printed as text (though it\n"
"            // doesn't have a terminating NULL)\n"
"            txtlog.value +=\n"
"              \"message (text): \" + decodestr(rdata, -1) + \"\\n\";\n"
"          else\n"
"            // This message should be printed as a sequence of\n"
"            // hex values.\n"
"            txtlog.value +=\n"
"              \"message (hex): \" + buf2hex(decodeslice(rdata, -1))\n"
"              + \"\\n\";\n"
"          break;\n"
"      }\n"
"      if (rdata.offset != msgoffset + msglen) {\n"
"        console.log(\n"
"          \"WARNING: msg of type \" + msgtype + \" was not fully\"\n"
"          + \" parsed.\");\n"
"        rdata.offset == msgoffset + msglen;\n"
"      }\n"
"      // update startoffset before parsing next msglen\n"
"      startoffset = rdata.offset;\n"
"    }\n"
"    rdata.condense();\n"
"  }\n"
"  document.getElementById(\"send2tone\").onclick = function() {\n"
"    send_send2tone();\n"
"  };\n"
"  document.getElementById(\"sendid\").onclick = function() {\n"
"    send_sendid();\n"
"  };\n"
"  document.getElementById(\"clearlog\").onclick = function() {\n"
"    txtlog.value = \"\";\n"
"  };\n"
"  document.getElementById(\"loghider\").onclick = function() {\n"
"    if (document.getElementById(\"loghider\").innerHTML == \"Show Log\") {\n"
"      document.getElementById(\"logdiv\").classList.remove(\"dnone\");\n"
"      document.getElementById(\"loghider\").innerHTML = \"Hide Log\";\n"
"    } else {\n"
"      document.getElementById(\"logdiv\").classList.add(\"dnone\");\n"
"      document.getElementById(\"loghider\").innerHTML = \"Show Log\";\n"
"    }\n"
"  };\n"
"  document.getElementById(\"infohider\").onclick = function() {\n"
"    if (document.getElementById(\"infohider\").innerHTML == \"Show Help\") {\n"
"      document.getElementById(\"info\").classList.remove(\"dnone\");\n"
"      document.getElementById(\"infohider\").innerHTML = \"Hide Help\";\n"
"    } else {\n"
"      document.getElementById(\"info\").classList.add(\"dnone\");\n"
"      document.getElementById(\"infohider\").innerHTML = \"Show Help\";\n"
"    }\n"
"  };\n"
"\n"
"  document.getElementById(\"text-log\").onkeydown = function(evt) {\n"
"    // text-log is intended to be readonly, but rather than set it\n"
"    // readonly in the html, just ignore all key presses except for\n"
"    // cursor movement keys (to allow keyboard scrolling).\n"
"    if (evt.keyCode < 33 || evt.keyCode > 40)\n"
"      evt.preventDefault();\n"
"  };\n"
"\n"
"  document.getElementById(\"hostcommand\").onkeydown = function(evt) {\n"
"    if (!devmode)\n"
"      // This function should only work in Dev Mode, which is enabled\n"
"      // by a msg from ardopcf.\n"
"      return;\n"
"    // Up and Down arrows can be used to scroll back and forward through\n"
"    // past commands.\n"
"    if (evt.keyCode == 38) { // up arrow\n"
"      if (cmdhistory.length == 0)\n"
"        return;\n"
"      if (cmdhistory_index == -1)\n"
"        cmdhistory_index = cmdhistory.length - 1;\n"
"      else if (cmdhistory_index != 0)\n"
"        cmdhistory_index -= 1;\n"
"      evt.target.value = cmdhistory[cmdhistory_index];\n"
"      return;\n"
"    }\n"
"    if (evt.keyCode == 40) { // down arrow\n"
"      if (cmdhistory.length == 0 || cmdhistory_index == -1)\n"
"        return;\n"
"      if (cmdhistory_index == cmdhistory.length - 1) {\n"
"        evt.target.value = \"\";\n"
"        cmdhistory_index = -1;\n"
"        return;\n"
"      }\n"
"      cmdhistory_index += 1;\n"
"      evt.target.value = cmdhistory[cmdhistory_index];\n"
"      return;\n"
"    }\n"
"    if (evt.keyCode != 13)\n"
"      // User has not pressed Enter.  Do nothing.\n"
"      return;\n"
"    // User has pressed Enter.  Send the command, update command histroy.\n"
"    var text = evt.target.value;\n"
"    if(text.length > 0) {\n"
"      send_msg(encoder.encode(\"H~\" + text), 2 + text.length);\n"
"    }\n"
"    cmdhistory.push(text);\n"
"    if (cmdhistory.length > cmdhistory_limit)\n"
"      // discard the oldest entry in cmdhistory.\n"
"      cmdhistory.shift();\n"
"    evt.target.value = \"\";\n"
"    cmdhistory_index = -1\n"
"  };\n"
"\n"
"\n"
"  const wfWidth = 205;\n"
"  const wfHeight = 100;\n"
"  const wfCanvas = document.getElementById(\"waterfall\");\n"
"  const wfCtx = wfCanvas.getContext(\"2d\");\n"
"  wfCtx.fillStyle = \"#000000\";\n"
"  wfCtx.fillRect(0, 0, wfWidth, wfHeight);\n"
"\n"
"  const spWidth = 205;\n"
"  const spHeight = 50;\n"
"  const spCanvas = document.getElementById(\"spectrum\");\n"
"  const spCtx = spCanvas.getContext(\"2d\");\n"
"  spCtx.fillStyle = \"#000000\";\n"
"  spCtx.fillRect(0, 0, spWidth, spHeight);\n"
"\n"
"  const cnstWidth = 90;\n"
"  const cnstHeight = 90;\n"
"  const cnstCanvas = document.getElementById(\"constellation\");\n"
"  const cnstCtx = cnstCanvas.getContext(\"2d\");\n"
"  cnstCtx.fillStyle = \"#000000\";\n"
"  cnstCtx.fillRect(0, 0, cnstWidth, cnstHeight);\n"
"\n"
"  const drawSpectrum = (values) => {\n"
"    spCtx.fillStyle = \"#000\";\n"
"    spCtx.fillRect(0, 0, plotscale * spWidth, plotscale * spHeight);\n"
"    spCtx.beginPath();\n"
"    spCtx.moveTo(0, plotscale * spHeight);\n"
"    for(var i=0; i<values.length; i++) {  // 2 frequency values per i\n"
"      spCtx.lineTo(\n"
"        plotscale*2*i,\n"
"        plotscale * (spHeight - (values[i] >> 4)*(spHeight/16)));\n"
"      spCtx.lineTo(\n"
"        plotscale*(2*i + 1),\n"
"        plotscale * (spHeight - (values[i] & 0x0F)*(spHeight/16)));\n"
"    }\n"
"    spCtx.lineTo(plotscale * spWidth, plotscale * spHeight);\n"
"    spCtx.moveTo(0, plotscale * spHeight); // close for fill\n"
"    spCtx.fillStyle = \"#CCC\";\n"
"    spCtx.strokeStyle = \"#CCC\";\n"
"    spCtx.fill();\n"
"    // draw bandwidth markers\n"
"    spCtx.beginPath();\n"
"    spCtx.moveTo(\n"
"      plotscale * (values.length - (bandwidth/2) / 11.719),\n"
"      0);\n"
"    spCtx.lineTo(\n"
"      plotscale * (values.length - (bandwidth/2) / 11.719),\n"
"      plotscale * spHeight)\n"
"    spCtx.moveTo(\n"
"      plotscale * (values.length + (bandwidth/2) / 11.719),\n"
"      plotscale * spHeight);\n"
"    spCtx.lineTo(\n"
"      plotscale * (values.length + (bandwidth/2) / 11.719),\n"
"      0);\n"
"    if (isbusy)\n"
"      spCtx.strokeStyle = \"#F0F\";\n"
"    else\n"
"      spCtx.strokeStyle = \"#DDD\";\n"
"    spCtx.stroke();\n"
"  };\n"
"\n"
"  const addWaterfallLine = (values) => {\n"
"    // shift the existing image down by plotscale pixels\n"
"    wfCtx.drawImage(\n"
"      wfCtx.canvas,\n"
"      0,\n"
"      0,\n"
"      plotscale * wfWidth,\n"
"      plotscale * wfHeight,\n"
"      0,\n"
"      plotscale,\n"
"      plotscale * wfWidth,\n"
"      plotscale * wfHeight);\n"
"    // expand values (4-bit uint per pixel) to colormap values (RGBA per pixel)\n"
"    let colorValues = new Uint8ClampedArray(\n"
"      plotscale * (2 * values.length) * 4); // filled with 0\n"
"    for(var i=0; i<values.length; i++) {  // 2 frequency values per i\n"
"      for (var k=0; k<plotscale; k++) {\n"
"        for (var j=0; j<4; j++) {  // r, g, b\n"
"          // first of two freqencies encoded in this byte\n"
"          colorValues[\n"
"            ((plotscale*(2*i) + k) * 4) + j\n"
"          ] = colormap[(values[i] >> 4)][j]; // RGBA\n"
"          // second of two freqencies encoded in this byte\n"
"          colorValues[\n"
"            ((plotscale*(2*i + 1) + k) * 4) + j\n"
"          ] = colormap[(values[i] & 0x0F)][j]; // RGBA\n"
"        }\n"
"      }\n"
"    }\n"
"    // overwrite centerline and bandwidth lines\n"
"    let bwcolor;\n"
"    if (isbusy)\n"
"      bwcolor = 19 // fuscia bandwidth\n"
"    else\n"
"      bwcolor = 17\n"
"    for (var j=0; j<4; j++) {  // r, g, b\n"
"      colorValues[\n"
"        plotscale * values.length*4 + j\n"
"      ] = colormap[16][j]; // black centerline\n"
"      colorValues[\n"
"        Math.round(\n"
"          plotscale * (values.length + (bandwidth/2) / 11.719)\n"
"        ) * 4 + j\n"
"      ] = colormap[bwcolor][j];\n"
"      colorValues[\n"
"        Math.round(\n"
"          plotscale * (values.length + (bandwidth/2) / 11.719) + 1\n"
"        ) * 4 + j\n"
"      ] = colormap[bwcolor][j];\n"
"      colorValues[\n"
"        Math.round(\n"
"          plotscale * (values.length - (bandwidth/2) / 11.719)\n"
"        ) * 4 + j\n"
"      ] = colormap[bwcolor][j];\n"
"      colorValues[\n"
"        Math.round(\n"
"          plotscale * (values.length - (bandwidth/2) / 11.719) + 1\n"
"        ) * 4 + j\n"
"      ] = colormap[bwcolor][j];\n"
"    }\n"
"    let imageData = new ImageData(\n"
"      colorValues, plotscale * 2 * values.length, 1);\n"
"    for (k=0; k<plotscale; k++) {\n"
"      wfCtx.putImageData(imageData, 0, k);\n"
"    }\n"
"  };\n"
"\n"
"  const drawCnstGridlines = () => {\n"
"    cnstCtx.beginPath();\n"
"    cnstCtx.moveTo(0, plotscale * cnstHeight / 2);\n"
"    cnstCtx.lineTo(plotscale * cnstWidth, plotscale * cnstHeight / 2);\n"
"    cnstCtx.moveTo(plotscale * cnstWidth / 2, 0);\n"
"    cnstCtx.lineTo(plotscale * cnstWidth / 2, plotscale * cnstHeight);\n"
"    cnstCtx.strokeStyle = \"#F0F\";\n"
"    cnstCtx.stroke();\n"
"  }\n"
"  const drawConstellation = (pixels) => {\n"
"    cnstCtx.fillStyle = \"#000000\";\n"
"    cnstCtx.fillRect(0, 0, plotscale * cnstWidth, plotscale * cnstHeight);\n"
"    let imageData = cnstCtx.getImageData(\n"
"      0, 0, plotscale * cnstWidth, plotscale * cnstHeight);\n"
"    let data = imageData.data\n"
"    for (var i=0; i<pixels.length/3; i++) {\n"
"      for (var kx=0; kx<plotscale; kx++) {\n"
"        for (var ky=0; ky<plotscale; ky++) {\n"
"          for (var j=0; j<3; j++) {  // r, g, b\n"
"            // ignore color data in pixels[3*i + 2], since this\n"
"            // is an index to a palette not currently defined\n"
"            //  here. plot everything as white.\n"
"            // alpha is unchanged at 0xFF\n"
"            data[\n"
"              (plotscale * pixels[3*i] + kx\n"
"              + ((plotscale * pixels[3*i+1] + ky) * plotscale\n"
"              * cnstWidth)) * 4 + j] = 0xFF // white\n"
"          }\n"
"        }\n"
"      }\n"
"    }\n"
"    cnstCtx.putImageData(imageData, 0, 0);\n"
"    drawCnstGridlines();\n"
"  };\n"
"\n"
"  document.getElementById(\"avglenslider\").oninput = function() {\n"
"    throttledcontrol(setavglen, 250, avglencontroltimer);\n"
"  }\n"
"  document.getElementById(\"plotscaleslider\").oninput = function() {\n"
"    plotscale = document.getElementById(\"plotscaleslider\").value;\n"
"    wfCanvas.width = plotscale * wfWidth;\n"
"    wfCanvas.height = plotscale * wfHeight;\n"
"    wfCtx.fillStyle = \"#000000\";\n"
"    wfCtx.fillRect(0, 0, plotscale * wfWidth, plotscale * wfHeight);\n"
"    spCanvas.width = plotscale * spWidth;\n"
"    spCanvas.height = plotscale * spHeight;\n"
"    cnstCanvas.width = plotscale * cnstWidth;\n"
"    cnstCanvas.height = plotscale * cnstHeight;\n"
"    cnstCtx.fillStyle = \"#000000\";\n"
"    cnstCtx.fillRect(0, 0, plotscale * cnstWidth, plotscale * cnstHeight);\n"
"    drawCnstGridlines();\n"
"  }\n"
"  document.getElementById(\"drivelevelslider\").oninput = function() {\n"
"    throttledcontrol(setdrivelevel, 250, drivelevelcontroltimer);\n"
"  }\n"
"\n"
"  WebSocketClient.init(\"ws://\" + document.location.host + \"/ws\");\n"
"  document.getElementById(\"hostcommand\").value = \"\";\n"
"  txtlog.value = \"[\" + (new Date().toISOString()) + \"]\\n\";\n"
"  txtlog.scrollTo(0, 0);\n"
"  plotscale = 1;\n"
"  document.getElementById(\"plotscaleslider\").value = 1;\n"
"  wfCtx.fillStyle = \"#000000\";\n"
"  wfCtx.fillRect(0, 0, wfWidth, wfHeight);\n"
"  drawCnstGridlines();\n"
"});\n"
"");
